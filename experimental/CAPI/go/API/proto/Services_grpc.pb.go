// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: Services.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AvailableServiceClient is the client API for AvailableService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AvailableServiceClient interface {
	TryConnection(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error)
	// 游戏开局调用一次的服务
	AddPlayer(ctx context.Context, in *PlayerMsg, opts ...grpc.CallOption) (AvailableService_AddPlayerClient, error)
	// 游戏过程中玩家执行操作的服务
	Move(ctx context.Context, in *MoveMsg, opts ...grpc.CallOption) (*MoveRes, error)
	PickProp(ctx context.Context, in *PropMsg, opts ...grpc.CallOption) (*BoolRes, error)
	UseProp(ctx context.Context, in *PropMsg, opts ...grpc.CallOption) (*BoolRes, error)
	ThrowProp(ctx context.Context, in *PropMsg, opts ...grpc.CallOption) (*BoolRes, error)
	UseSkill(ctx context.Context, in *SkillMsg, opts ...grpc.CallOption) (*BoolRes, error)
	SendMessage(ctx context.Context, in *SendMsg, opts ...grpc.CallOption) (*BoolRes, error)
	// rpc GetMessage (IDMsg) returns (stream MsgRes);
	StartLearning(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error)
	StartRescueMate(ctx context.Context, in *TreatAndRescueMsg, opts ...grpc.CallOption) (*BoolRes, error)
	StartTreatMate(ctx context.Context, in *TreatAndRescueMsg, opts ...grpc.CallOption) (*BoolRes, error)
	Attack(ctx context.Context, in *AttackMsg, opts ...grpc.CallOption) (*BoolRes, error)
	Graduate(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error)
	OpenDoor(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error)
	CloseDoor(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error)
	SkipWindow(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error)
	StartOpenGate(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error)
	StartOpenChest(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error)
	EndAllAction(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error)
}

type availableServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAvailableServiceClient(cc grpc.ClientConnInterface) AvailableServiceClient {
	return &availableServiceClient{cc}
}

func (c *availableServiceClient) TryConnection(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/TryConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) AddPlayer(ctx context.Context, in *PlayerMsg, opts ...grpc.CallOption) (AvailableService_AddPlayerClient, error) {
	stream, err := c.cc.NewStream(ctx, &AvailableService_ServiceDesc.Streams[0], "/protobuf.AvailableService/AddPlayer", opts...)
	if err != nil {
		return nil, err
	}
	x := &availableServiceAddPlayerClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AvailableService_AddPlayerClient interface {
	Recv() (*MessageToClient, error)
	grpc.ClientStream
}

type availableServiceAddPlayerClient struct {
	grpc.ClientStream
}

func (x *availableServiceAddPlayerClient) Recv() (*MessageToClient, error) {
	m := new(MessageToClient)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *availableServiceClient) Move(ctx context.Context, in *MoveMsg, opts ...grpc.CallOption) (*MoveRes, error) {
	out := new(MoveRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/Move", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) PickProp(ctx context.Context, in *PropMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/PickProp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) UseProp(ctx context.Context, in *PropMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/UseProp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) ThrowProp(ctx context.Context, in *PropMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/ThrowProp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) UseSkill(ctx context.Context, in *SkillMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/UseSkill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) SendMessage(ctx context.Context, in *SendMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/SendMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) StartLearning(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/StartLearning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) StartRescueMate(ctx context.Context, in *TreatAndRescueMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/StartRescueMate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) StartTreatMate(ctx context.Context, in *TreatAndRescueMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/StartTreatMate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) Attack(ctx context.Context, in *AttackMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/Attack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) Graduate(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/Graduate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) OpenDoor(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/OpenDoor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) CloseDoor(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/CloseDoor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) SkipWindow(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/SkipWindow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) StartOpenGate(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/StartOpenGate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) StartOpenChest(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/StartOpenChest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *availableServiceClient) EndAllAction(ctx context.Context, in *IDMsg, opts ...grpc.CallOption) (*BoolRes, error) {
	out := new(BoolRes)
	err := c.cc.Invoke(ctx, "/protobuf.AvailableService/EndAllAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AvailableServiceServer is the server API for AvailableService service.
// All implementations should embed UnimplementedAvailableServiceServer
// for forward compatibility
type AvailableServiceServer interface {
	TryConnection(context.Context, *IDMsg) (*BoolRes, error)
	// 游戏开局调用一次的服务
	AddPlayer(*PlayerMsg, AvailableService_AddPlayerServer) error
	// 游戏过程中玩家执行操作的服务
	Move(context.Context, *MoveMsg) (*MoveRes, error)
	PickProp(context.Context, *PropMsg) (*BoolRes, error)
	UseProp(context.Context, *PropMsg) (*BoolRes, error)
	ThrowProp(context.Context, *PropMsg) (*BoolRes, error)
	UseSkill(context.Context, *SkillMsg) (*BoolRes, error)
	SendMessage(context.Context, *SendMsg) (*BoolRes, error)
	// rpc GetMessage (IDMsg) returns (stream MsgRes);
	StartLearning(context.Context, *IDMsg) (*BoolRes, error)
	StartRescueMate(context.Context, *TreatAndRescueMsg) (*BoolRes, error)
	StartTreatMate(context.Context, *TreatAndRescueMsg) (*BoolRes, error)
	Attack(context.Context, *AttackMsg) (*BoolRes, error)
	Graduate(context.Context, *IDMsg) (*BoolRes, error)
	OpenDoor(context.Context, *IDMsg) (*BoolRes, error)
	CloseDoor(context.Context, *IDMsg) (*BoolRes, error)
	SkipWindow(context.Context, *IDMsg) (*BoolRes, error)
	StartOpenGate(context.Context, *IDMsg) (*BoolRes, error)
	StartOpenChest(context.Context, *IDMsg) (*BoolRes, error)
	EndAllAction(context.Context, *IDMsg) (*BoolRes, error)
}

// UnimplementedAvailableServiceServer should be embedded to have forward compatible implementations.
type UnimplementedAvailableServiceServer struct {
}

func (UnimplementedAvailableServiceServer) TryConnection(context.Context, *IDMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TryConnection not implemented")
}
func (UnimplementedAvailableServiceServer) AddPlayer(*PlayerMsg, AvailableService_AddPlayerServer) error {
	return status.Errorf(codes.Unimplemented, "method AddPlayer not implemented")
}
func (UnimplementedAvailableServiceServer) Move(context.Context, *MoveMsg) (*MoveRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Move not implemented")
}
func (UnimplementedAvailableServiceServer) PickProp(context.Context, *PropMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PickProp not implemented")
}
func (UnimplementedAvailableServiceServer) UseProp(context.Context, *PropMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UseProp not implemented")
}
func (UnimplementedAvailableServiceServer) ThrowProp(context.Context, *PropMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ThrowProp not implemented")
}
func (UnimplementedAvailableServiceServer) UseSkill(context.Context, *SkillMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UseSkill not implemented")
}
func (UnimplementedAvailableServiceServer) SendMessage(context.Context, *SendMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedAvailableServiceServer) StartLearning(context.Context, *IDMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartLearning not implemented")
}
func (UnimplementedAvailableServiceServer) StartRescueMate(context.Context, *TreatAndRescueMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartRescueMate not implemented")
}
func (UnimplementedAvailableServiceServer) StartTreatMate(context.Context, *TreatAndRescueMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTreatMate not implemented")
}
func (UnimplementedAvailableServiceServer) Attack(context.Context, *AttackMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attack not implemented")
}
func (UnimplementedAvailableServiceServer) Graduate(context.Context, *IDMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Graduate not implemented")
}
func (UnimplementedAvailableServiceServer) OpenDoor(context.Context, *IDMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenDoor not implemented")
}
func (UnimplementedAvailableServiceServer) CloseDoor(context.Context, *IDMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseDoor not implemented")
}
func (UnimplementedAvailableServiceServer) SkipWindow(context.Context, *IDMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SkipWindow not implemented")
}
func (UnimplementedAvailableServiceServer) StartOpenGate(context.Context, *IDMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartOpenGate not implemented")
}
func (UnimplementedAvailableServiceServer) StartOpenChest(context.Context, *IDMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartOpenChest not implemented")
}
func (UnimplementedAvailableServiceServer) EndAllAction(context.Context, *IDMsg) (*BoolRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndAllAction not implemented")
}

// UnsafeAvailableServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AvailableServiceServer will
// result in compilation errors.
type UnsafeAvailableServiceServer interface {
	mustEmbedUnimplementedAvailableServiceServer()
}

func RegisterAvailableServiceServer(s grpc.ServiceRegistrar, srv AvailableServiceServer) {
	s.RegisterService(&AvailableService_ServiceDesc, srv)
}

func _AvailableService_TryConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).TryConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/TryConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).TryConnection(ctx, req.(*IDMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_AddPlayer_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PlayerMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AvailableServiceServer).AddPlayer(m, &availableServiceAddPlayerServer{stream})
}

type AvailableService_AddPlayerServer interface {
	Send(*MessageToClient) error
	grpc.ServerStream
}

type availableServiceAddPlayerServer struct {
	grpc.ServerStream
}

func (x *availableServiceAddPlayerServer) Send(m *MessageToClient) error {
	return x.ServerStream.SendMsg(m)
}

func _AvailableService_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/Move",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).Move(ctx, req.(*MoveMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_PickProp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PropMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).PickProp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/PickProp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).PickProp(ctx, req.(*PropMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_UseProp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PropMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).UseProp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/UseProp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).UseProp(ctx, req.(*PropMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_ThrowProp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PropMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).ThrowProp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/ThrowProp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).ThrowProp(ctx, req.(*PropMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_UseSkill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SkillMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).UseSkill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/UseSkill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).UseSkill(ctx, req.(*SkillMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/SendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).SendMessage(ctx, req.(*SendMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_StartLearning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).StartLearning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/StartLearning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).StartLearning(ctx, req.(*IDMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_StartRescueMate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TreatAndRescueMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).StartRescueMate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/StartRescueMate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).StartRescueMate(ctx, req.(*TreatAndRescueMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_StartTreatMate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TreatAndRescueMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).StartTreatMate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/StartTreatMate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).StartTreatMate(ctx, req.(*TreatAndRescueMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_Attack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttackMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).Attack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/Attack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).Attack(ctx, req.(*AttackMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_Graduate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).Graduate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/Graduate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).Graduate(ctx, req.(*IDMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_OpenDoor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).OpenDoor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/OpenDoor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).OpenDoor(ctx, req.(*IDMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_CloseDoor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).CloseDoor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/CloseDoor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).CloseDoor(ctx, req.(*IDMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_SkipWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).SkipWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/SkipWindow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).SkipWindow(ctx, req.(*IDMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_StartOpenGate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).StartOpenGate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/StartOpenGate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).StartOpenGate(ctx, req.(*IDMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_StartOpenChest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).StartOpenChest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/StartOpenChest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).StartOpenChest(ctx, req.(*IDMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvailableService_EndAllAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvailableServiceServer).EndAllAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.AvailableService/EndAllAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvailableServiceServer).EndAllAction(ctx, req.(*IDMsg))
	}
	return interceptor(ctx, in, info, handler)
}

// AvailableService_ServiceDesc is the grpc.ServiceDesc for AvailableService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AvailableService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protobuf.AvailableService",
	HandlerType: (*AvailableServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TryConnection",
			Handler:    _AvailableService_TryConnection_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _AvailableService_Move_Handler,
		},
		{
			MethodName: "PickProp",
			Handler:    _AvailableService_PickProp_Handler,
		},
		{
			MethodName: "UseProp",
			Handler:    _AvailableService_UseProp_Handler,
		},
		{
			MethodName: "ThrowProp",
			Handler:    _AvailableService_ThrowProp_Handler,
		},
		{
			MethodName: "UseSkill",
			Handler:    _AvailableService_UseSkill_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _AvailableService_SendMessage_Handler,
		},
		{
			MethodName: "StartLearning",
			Handler:    _AvailableService_StartLearning_Handler,
		},
		{
			MethodName: "StartRescueMate",
			Handler:    _AvailableService_StartRescueMate_Handler,
		},
		{
			MethodName: "StartTreatMate",
			Handler:    _AvailableService_StartTreatMate_Handler,
		},
		{
			MethodName: "Attack",
			Handler:    _AvailableService_Attack_Handler,
		},
		{
			MethodName: "Graduate",
			Handler:    _AvailableService_Graduate_Handler,
		},
		{
			MethodName: "OpenDoor",
			Handler:    _AvailableService_OpenDoor_Handler,
		},
		{
			MethodName: "CloseDoor",
			Handler:    _AvailableService_CloseDoor_Handler,
		},
		{
			MethodName: "SkipWindow",
			Handler:    _AvailableService_SkipWindow_Handler,
		},
		{
			MethodName: "StartOpenGate",
			Handler:    _AvailableService_StartOpenGate_Handler,
		},
		{
			MethodName: "StartOpenChest",
			Handler:    _AvailableService_StartOpenChest_Handler,
		},
		{
			MethodName: "EndAllAction",
			Handler:    _AvailableService_EndAllAction_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AddPlayer",
			Handler:       _AvailableService_AddPlayer_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "Services.proto",
}
